# Руководство для разработчиков go-apt-proxy

## Структура проекта

Проект имеет следующую структуру:

```
go-apt-proxy/
├── main.go                  # Точка входа в приложение
├── go.mod                   # Объявление модуля и зависимостей
├── go.sum                   # Контрольные суммы зависимостей
├── internal/                # Внутренние пакеты
│   ├── cache/               # Реализация кеширования
│   │   └── cache.go
│   ├── config/              # Работа с конфигурацией
│   │   └── config.go
│   ├── fetch/               # Загрузка файлов из репозиториев
│   │   └── fetch.go
│   ├── logging/             # Настройка логирования
│   │   └── logging.go
│   ├── server/              # HTTP-сервер и обработчики
│   │   ├── server.go
│   │   └── middleware.go
│   └── util/                # Вспомогательные функции
│       └── util.go
├── docs/                    # Документация
│   ├── INSTALL.md
│   └── DEVELOPMENT.md
└── README.md                # Общее описание проекта
```

## Настройка окружения для разработки

1. Установите Go (версии 1.18 или новее): https://golang.org/doc/install
2. Клонируйте репозиторий:

```bash
git clone https://github.com/yolkispalkis/go-apt-cache.git
cd go-apt-cache
```

3. Установите зависимости:

```bash
go mod download
```

## Сборка и запуск

### Сборка проекта

```bash
go build -o go-apt-proxy main.go
```

### Запуск с отладочной информацией

```bash
./go-apt-proxy -config config.json -log-level debug
```

### Запуск тестов

```bash
go test ./...
```

## Архитектура проекта

### Основные компоненты

#### Server

Сервер реализует HTTP-обработчики для проксирования запросов. Ключевые функции:

- Маршрутизация запросов к соответствующим репозиториям
- Обработка заголовков кеширования
- Отдача статусной информации

#### Cache Manager

Реализует LRU (Least Recently Used) кеш на диске:

- Отслеживание размера кеша и освобождение места при необходимости
- Сохранение метаданных о кешированных файлах
- Валидация кешированных данных по времени

#### Fetch Coordinator

Координирует загрузку файлов из репозиториев:

- Ограничение количества одновременных запросов
- Обработка ошибок сети
- Парсинг заголовков ответа

#### Config

Управляет конфигурацией приложения:

- Загрузка и сохранение конфигурации из JSON-файла
- Валидация параметров конфигурации
- Применение значений из командной строки

#### Logging

Настраиваемое логирование:

- Уровни логирования (debug, info, warn, error)
- Ротация файлов логов
- Вывод в терминал и/или файл

### Потоки данных

1. Клиент отправляет HTTP-запрос к серверу
2. Сервер проверяет, есть ли запрошенный файл в кеше
3. Если файл есть в кеше и не устарел, он отправляется клиенту
4. Если файла нет или он устарел, запрос перенаправляется к Fetch Coordinator
5. Fetch Coordinator скачивает файл из репозитория
6. Скачанный файл одновременно отправляется клиенту и сохраняется в кеше
7. Cache Manager управляет размером кеша, удаляя старые файлы при необходимости

## Руководство по стилю кода

### Форматирование кода

- Используйте `go fmt` перед коммитом для форматирования кода
- Установите и используйте `golint` и `go vet` для проверки кода

### Именование

- Используйте camelCase для переменных и функций
- Используйте PascalCase для экспортируемых имен
- Используйте snake_case для файлов и директорий

### Документация

- Документируйте все экспортируемые типы, функции и методы
- Используйте полные предложения с точкой в конце
- Начинайте комментарии с имени объекта, которое документируете

Пример:
```go
// Server handles HTTP requests and manages cache access.
type Server struct {
    // ...
}

// New creates a new server instance with the given configuration.
func New(cfg *config.Config) (*Server, error) {
    // ...
}
```

## Процесс разработки

### Ветвление

- `main` - стабильная ветка с релизами
- `develop` - ветка разработки
- Используйте feature-ветки для новых функций
- Используйте bugfix-ветки для исправления ошибок

### Коммиты

Используйте семантические коммиты в формате:

```
<тип>(<область>): <сообщение>
```

Типы:
- feat: новая функциональность
- fix: исправление ошибки
- docs: изменения в документации
- refactor: рефакторинг кода
- test: добавление или изменение тестов
- chore: обновление сборочных скриптов и т.п.

Примеры:
```
feat(cache): add support for disk quota limiting
fix(server): handle connection timeouts properly
docs: update installation instructions
```

### Pull Requests

- Создавайте PR из feature-веток в develop
- Описывайте изменения, которые вносит PR
- Убедитесь, что все тесты проходят
- Запрашивайте код-ревью перед слиянием

## Добавление новых функций

### Новый репозиторий

Для добавления нового типа репозитория:

1. Создайте новый обработчик в `internal/server`
2. Добавьте необходимые параметры в конфигурацию
3. Зарегистрируйте обработчик в `server.New`

### Расширение кеша

Для расширения функциональности кеша:

1. Реализуйте новую стратегию кеширования в `internal/cache`
2. Следуйте интерфейсу `CacheManager`
3. Обновите фабричную функцию `NewDiskLRUCache`

## Прикладное API

Внешний API предоставляется только через HTTP. Основные эндпоинты:

- `GET /{repository}/{path}` - получение файла из репозитория
- `GET /status` - получение информации о состоянии сервера

## Производительность

### Профилирование

Для профилирования используйте встроенные инструменты Go:

```go
import _ "net/http/pprof"

func main() {
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    // ...
}
```

Затем:

```bash
go tool pprof http://localhost:6060/debug/pprof/heap
go tool pprof http://localhost:6060/debug/pprof/profile
```

### Оптимизация кеша

- Используйте `pread` для чтения частей файлов без загрузки всего файла
- Минимизируйте блокировки мьютексов
- Используйте буферизированные каналы для асинхронных операций 